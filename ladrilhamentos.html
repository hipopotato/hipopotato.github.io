<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google-site-verification" content="LiYCKidjfsyxb615zTwvCFEzp2_DPelhKscx3tpmVgU" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <title>Alunos</title>
</head>
<body>
 <div id="navbar"></div> <!-- Aqui será inserida a barra de navegação -->

    <script>
        // Carregar a navegação automaticamente
        fetch("navbar.html")
            .then(response => response.text())
            .then(data => document.getElementById("navbar").innerHTML = data);
    </script>

    <!-- Cabeçalho -->
    <header class="main-header">
 <h1>Animações de Ladrilhamentos Bem Comportados com manim e IA</h1>
       </header>
    <section class="section1">
      <p style="text-align: justify;">
    Nesta seção, disponibilizo vídeos e os códigos-fonte correspondentes de algumas construções matemáticas que realizei.

As animações foram feitas em Python com a biblioteca Manim. Para a elaboração dos scripts, utilizei o ChatGPT como ferramenta, fornecendo os comandos e fazendo os ajustes necessários até chegar ao resultado final.

O tema explorado são os ladrilhamentos bem-comportados. De forma rápida, um ladrilhamento é 'bem-comportado' quando preenche o plano perfeitamente, sem falhas ou sobreposições, usando apenas polígonos regulares, com a interseção sendo apenas um lado ou vértice e a distribuição de polígonos em cada vértice é sempre a mesma.
      
      Existem 11 tipos de ladrilhamentos bem comportados. Dentre eles, três são formados por polígonos regulares de um único tipo: o triangular, com padrão (3,3,3,3,3,3); o quadrado, com padrão (4,4,4,4); e o hexagonal, com padrão (6,6,6). Os oito restantes são formados por dois ou mais tipos de polígonos regulares, sendo eles: (3,12,12), (4,6,12), (4,8,8), (3,4,6,4), (3,6,3,6), (3,3,3,4,4), (3,3,3,3,6) e (3,4,3,3,4). A seguir, apresentam-se os códigos utilizados e os vídeos renderizados correspondentes a cada construção.</p>

    </section>section>
    <section class="section2">
  <h2>Ladrilhamento (4,6,12)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo1">
    <pre><code>
from manim import *
import numpy as np

class Tiling124(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = WHITE  # 1. Fundo branco
        L = 1.0  # comprimento do lado dos polígonos

        all_polygons = VGroup()  # grupo para armazenar todos os polígonos

        # --- Função auxiliar para criar e posicionar polígonos ---
        def attach_polygon(n_sides, color, target_side, reference_center):
            radius = L / (2 * np.sin(PI / n_sides))
            poly = RegularPolygon(n=n_sides, radius=radius)
            poly.set_fill(color, opacity=1)
            poly.set_stroke(BLACK, width=2) # 1. Borda preta

            # alinhamento do lado
            v = poly.get_vertices()
            p1, p2 = v[0], v[1]

            # Translacao
            shift_vec = target_side[0] - p1
            poly.shift(shift_vec)
            p2_new = p2 + shift_vec

            # Rotação
            angle_target = np.angle(complex(*(target_side[1] - target_side[0])[:2]))
            angle_current = np.angle(complex(*(p2_new - target_side[0])[:2]))
            poly.rotate(angle_target - angle_current, about_point=target_side[0])

            # Garantir que fique para fora
            mid_side = (target_side[0] + target_side[1]) / 2
            center_poly = poly.get_center()
            outward_vec_ref = mid_side - reference_center
            outward_vec_poly = center_poly - mid_side
            if np.dot(outward_vec_poly, outward_vec_ref) < 0:
                poly.rotate(PI, about_point=mid_side)

            return poly

        # --- Função para evitar duplicatas ---
        def is_duplicate(poly, group):
            if not group:
                return False
            for p in group:
                if np.linalg.norm(poly.get_center() - p.get_center()) < 0.01:
                    return True
            return False

        # --- Dodecágono central ---
        dodecagon = RegularPolygon(n=12, radius=L / (2*np.sin(PI/12)))
        dodecagon.set_fill(BLUE, opacity=1)
        dodecagon.set_stroke(BLACK, width=2) # 1. Borda preta
        all_polygons.add(dodecagon)
        self.play(Create(dodecagon), run_time=1.5)

        # --- Primeira camada: quadrados e hexágonos nos vértices ---
        first_layer = VGroup()
        vertices = dodecagon.get_vertices()
        for i in range(12):
            v_prev = vertices[i-1]
            v_curr = vertices[i]
            v_next = vertices[(i+1)%12]

            if i % 2 == 0:
                square = attach_polygon(4, RED, (v_curr, v_next), dodecagon.get_center())
                first_layer.add(square)
                hexagon = attach_polygon(6, GREEN, (v_prev, v_curr), dodecagon.get_center())
                first_layer.add(hexagon)
            else:
                hexagon = attach_polygon(6, GREEN, (v_curr, v_next), dodecagon.get_center())
                first_layer.add(hexagon)
                square = attach_polygon(4, RED, (v_prev, v_curr), dodecagon.get_center())
                first_layer.add(square)

        all_polygons.add(*first_layer)
        self.play(Create(first_layer), run_time=2)

        # --- Segunda camada: expansão ---
        second_layer = VGroup()
        second_layer_polys_list = [] # Lista para guardar polígonos para a próxima camada
        for poly in first_layer:
            vertices = poly.get_vertices()
            num_sides = len(vertices)
            center_ref = dodecagon.get_center()

            min_dist = float('inf')
            attached_edge_index = 0
            for i in range(num_sides):
                mid = (vertices[i] + vertices[(i+1)%num_sides])/2
                dist = np.linalg.norm(mid - center_ref)
                if dist < min_dist:
                    min_dist = dist
                    attached_edge_index = i

            if num_sides == 4:
                free_edge_index = (attached_edge_index + 2) % 4
                side_free = (vertices[free_edge_index], vertices[(free_edge_index+1)%4])
                new_dode = attach_polygon(12, BLUE, side_free, poly.get_center())
                if not is_duplicate(new_dode, all_polygons):
                    second_layer.add(new_dode)
                    all_polygons.add(new_dode)
                    second_layer_polys_list.append(new_dode)
                
                for offset in [1, 3]:
                    lateral_edge_index = (attached_edge_index + offset) % 4
                    side_lateral = (vertices[lateral_edge_index], vertices[(lateral_edge_index+1)%4])
                    new_hexagon = attach_polygon(6, GREEN, side_lateral, poly.get_center())
                    if not is_duplicate(new_hexagon, all_polygons):
                        second_layer.add(new_hexagon)
                        all_polygons.add(new_hexagon)
                        second_layer_polys_list.append(new_hexagon)
            
            elif num_sides == 6:
                opposite_edge_index = (attached_edge_index + 3) % 6
                side_opposite = (vertices[opposite_edge_index], vertices[(opposite_edge_index+1)%6])
                new_square = attach_polygon(4, RED, side_opposite, poly.get_center())
                if not is_duplicate(new_square, all_polygons):
                    second_layer.add(new_square)
                    all_polygons.add(new_square)
                    second_layer_polys_list.append(new_square)

        self.play(Create(second_layer), run_time=3)
        self.wait(0.5)

        # --- 2. Terceira camada: completando os dodecágonos externos ---
        third_layer = VGroup()
        for base_poly in second_layer_polys_list:
            # Apenas expandir a partir dos novos dodecágonos
            if len(base_poly.get_vertices()) == 12:
                vertices = base_poly.get_vertices()
                
                # Encontra a aresta "interna", mais próxima do centro (0,0)
                min_dist = float('inf')
                attached_edge_index = 0
                for i in range(12):
                    mid = (vertices[i] + vertices[(i+1)%12])/2
                    dist = np.linalg.norm(mid)
                    if dist < min_dist:
                        min_dist = dist
                        attached_edge_index = i
                
                # Itera sobre as 11 arestas livres
                for offset in range(1, 12):
                    edge_index = (attached_edge_index + offset) % 12
                    side = (vertices[edge_index], vertices[(edge_index + 1) % 12])
                    
                    # Alterna entre hexágono e quadrado
                    if offset % 2 != 0: # Ímpar: Hexágono
                        new_poly = attach_polygon(6, GREEN, side, base_poly.get_center())
                    else: # Par: Quadrado
                        new_poly = attach_polygon(4, RED, side, base_poly.get_center())
                    
                    if not is_duplicate(new_poly, all_polygons):
                        third_layer.add(new_poly)
                        all_polygons.add(new_poly)
        
        self.play(Create(third_layer), run_time=4)
        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo1')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/zSOAJamGVpg"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>


<section class="section3">
  <h2>Ladrilhamento (3,12,12)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo2">
    <pre><code>
from manim import *
import numpy as np

class Tiling3_12_12(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#333333" # Fundo escuro para contraste
        L = 1.0  # Comprimento do lado dos polígonos

        # --- Cores ---
        COLOR_DODEC = BLUE
        COLOR_TRI = ORANGE

        # Conjunto para armazenar coordenadas de centros e evitar duplicatas
        existing_centers = set()

        # --- Funções Auxiliares ---
        def add_polygon_if_unique(poly, group_to_add):
            """Adiciona um polígono a um grupo se ele não for um duplicado."""
            center = poly.get_center()
            rounded_center = (round(center[0], 2), round(center[1], 2))
            
            if rounded_center not in existing_centers:
                existing_centers.add(rounded_center)
                group_to_add.add(poly)
                return True
            return False

        def attach_polygon(n_sides, color, target_side):
            """Cria e anexa um polígono a uma aresta específica."""
            radius = L / (2 * np.sin(PI / n_sides))
            poly = RegularPolygon(n=n_sides, radius=radius)
            poly.set_fill(color, opacity=1).set_stroke(BLACK, width=2)

            v = poly.get_vertices()
            p1, p2 = v[0], v[1]
            
            poly.shift(target_side[0] - p1)
            
            p2_new = p2 + (target_side[0] - p1)
            angle_target = angle_of_vector(target_side[1] - target_side[0])
            angle_current = angle_of_vector(p2_new - target_side[0])
            poly.rotate(angle_target - angle_current, about_point=target_side[0])
            
            return poly

        # --- Camada 0: Dodecágono Central ---
        dodecagon = RegularPolygon(n=12, radius=L / (2*np.sin(PI/12)))
        dodecagon.set_fill(COLOR_DODEC, opacity=1).set_stroke(BLACK, width=2)
        
        layer0_group = VGroup()
        add_polygon_if_unique(dodecagon, layer0_group)
        self.play(Create(layer0_group))
        self.wait(0.5)

        # --- Camada 1: Primeira Expansão (Dodecágonos e Triângulos) ---
        layer1_group = VGroup()
        layer1_polys_list = [] # Lista para iterar na próxima camada
        dodec_vertices = dodecagon.get_vertices()

        for i in range(12):
            # Inverte a aresta para construir para fora
            side = (dodec_vertices[(i + 1) % 12], dodec_vertices[i])
            
            if i % 2 == 0: # Arestas pares recebem dodecágonos
                new_poly = attach_polygon(12, COLOR_DODEC, side)
            else: # Arestas ímpares recebem triângulos
                new_poly = attach_polygon(3, COLOR_TRI, side)
            
            if add_polygon_if_unique(new_poly, layer1_group):
                layer1_polys_list.append(new_poly)

        self.play(Create(layer1_group), run_time=3)
        self.wait(0.5)
        
        # --- Camada 2: Segunda Expansão ---
        layer2_group = VGroup()
        for base_poly in layer1_polys_list:
            vertices = base_poly.get_vertices()
            num_sides = len(vertices)

            # Encontra a aresta "interna" (mais próxima do centro da cena)
            min_dist = float('inf')
            attached_edge_index = 0
            for i in range(num_sides):
                mid = (vertices[i] + vertices[(i + 1) % num_sides]) / 2
                dist = np.linalg.norm(mid)
                if dist < min_dist:
                    min_dist = dist
                    attached_edge_index = i
            
            # Expansão a partir de um TRIÂNGULO
            if num_sides == 3:
                # As 2 arestas livres recebem dodecágonos
                for offset in [1, 2]:
                    edge_index = (attached_edge_index + offset) % num_sides
                    side = (vertices[(edge_index + 1) % num_sides], vertices[edge_index])
                    new_dodec = attach_polygon(12, COLOR_DODEC, side)
                    add_polygon_if_unique(new_dodec, layer2_group)
            
            # Expansão a partir de um DODECÁGONO
            elif num_sides == 12:
                # As 9 arestas livres recebem um padrão alternado de D-T-D-T...
                for offset in range(2, 11): # As arestas com offset 0, 1 e 11 estão ocupadas
                    edge_index = (attached_edge_index + offset) % num_sides
                    side = (vertices[(edge_index + 1) % num_sides], vertices[edge_index])
                    
                    if offset % 2 == 0: # Posição par no padrão livre: Dodecágono
                         new_poly = attach_polygon(12, COLOR_DODEC, side)
                    else: # Posição ímpar no padrão livre: Triângulo
                         new_poly = attach_polygon(3, COLOR_TRI, side)
                    
                    add_polygon_if_unique(new_poly, layer2_group)

        self.play(Create(layer2_group), run_time=4)
        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo2')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://youtu.be/hGGUnIBu5Xc"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>
                        
<section class="section3"> 
</div>



  
    <div class="section4">
    </div>


    <div class="section3">
    </div>

</body>
</html>
