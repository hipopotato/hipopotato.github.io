<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google-site-verification" content="LiYCKidjfsyxb615zTwvCFEzp2_DPelhKscx3tpmVgU" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <title>Ladrilhamentos</title>
</head>
<body>
 <div id="navbar"></div> <!-- Aqui será inserida a barra de navegação -->

    <script>
        // Carregar a navegação automaticamente
        fetch("navbar.html")
            .then(response => response.text())
            .then(data => document.getElementById("navbar").innerHTML = data);
    </script>

    <!-- Cabeçalho -->
    <header class="main-header">
 <h1>Animações de Ladrilhamentos Bem Comportados com manim e IA</h1>
       </header>
    <section class="section1">
      <p style="text-align: justify;">
    Nesta seção, disponibilizo vídeos e os códigos-fonte correspondentes de algumas construções matemáticas que realizei.

As animações foram feitas em Python com a biblioteca Manim. Para a elaboração dos scripts, utilizei o ChatGPT como ferramenta, fornecendo os comandos e fazendo os ajustes necessários até chegar ao resultado final.

O tema explorado são os ladrilhamentos bem-comportados. De forma rápida, um ladrilhamento é 'bem-comportado' quando preenche o plano perfeitamente, sem falhas ou sobreposições, usando apenas polígonos regulares, com a interseção sendo apenas um lado ou vértice e a distribuição de polígonos em cada vértice é sempre a mesma.
      
      Existem 11 tipos de ladrilhamentos bem comportados. Dentre eles, três são formados por polígonos regulares de um único tipo: o triangular, com padrão (3,3,3,3,3,3); o quadrado, com padrão (4,4,4,4); e o hexagonal, com padrão (6,6,6). Os oito restantes são formados por dois ou mais tipos de polígonos regulares, sendo eles: (3,12,12), (4,6,12), (4,8,8), (3,4,6,4), (3,6,3,6), (3,3,3,4,4), (3,3,3,3,6) e (3,4,3,3,4). A seguir, apresentam-se os códigos utilizados e os vídeos renderizados correspondentes a cada construção.</p>

    </section>

<header class="main-header">
 <h2>Ladrilhamentos Bem Comportados Regulares</h2>
       </header>
  <section class="section01">
  <h2>Ladrilhamento (3,3,3,3,3,3)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo01">
    <pre><code>
from manim import *
import numpy as np

class Tiling333333(Scene):
    def construct(self):
        self.camera.background_color = "#333333"
        L = 3  # lado do triângulo
        COLOR_TRI = ORANGE

        # Sistema para evitar duplicatas
        existing_centers = set()
        def add_polygon_if_unique(poly, group_to_add):
            center = poly.get_center()
            rounded_center = (round(center[0], 2), round(center[1], 2))
            if rounded_center not in existing_centers:
                existing_centers.add(rounded_center)
                group_to_add.add(poly)
                return True
            return False

        # Função para criar triângulo equilátero apontando "para cima" dado um ponto central
        def make_triangle(center, pointing_up=True):
            h = np.sqrt(3) * L / 2
            if pointing_up:
                p1 = center + np.array([-L/2, -h/3, 0])
                p2 = center + np.array([L/2, -h/3, 0])
                p3 = center + np.array([0, 2*h/3, 0])
            else:
                p1 = center + np.array([-L/2, h/3, 0])
                p2 = center + np.array([L/2, h/3, 0])
                p3 = center + np.array([0, -2*h/3, 0])
            return Polygon(p1, p2, p3, color=COLOR_TRI, fill_opacity=1).set_stroke(BLACK, 2)

        # --- Triângulo inicial ---
        center_tri = make_triangle(np.array([0,0,0]), pointing_up=True)
        layer = VGroup()
        add_polygon_if_unique(center_tri, layer)

        self.play(Create(center_tri))
        self.wait(0.5)

        # --- Construir várias camadas ---
        n_camadas = 7  # aumente para expandir mais
        all_tris = [center_tri]

        for _ in range(n_camadas):
            new_layer = VGroup()
            for tri in all_tris:
                verts = tri.get_vertices()
                # Para cada lado do triângulo
                for i in range(3):
                    p1, p2 = verts[i], verts[(i+1)%3]
                    # centro do lado
                    mid = (p1 + p2) / 2
                    # vetor perpendicular
                    edge_vec = p2 - p1
                    side_len = np.linalg.norm(edge_vec)
                    height = side_len * np.sqrt(3) / 2
                    perp_vec = rotate_vector(edge_vec, -PI/2)
                    unit_perp = perp_vec / side_len

                    # ponto externo
                    candidate1 = mid + unit_perp * height
                    candidate2 = mid - unit_perp * height
                    # pega o que não é o vértice do triângulo atual
                    chosen = candidate1
                    if np.linalg.norm(chosen - tri.get_center()) < np.linalg.norm(candidate2 - tri.get_center()):
                        chosen = candidate2

                    new_tri = Polygon(p1, p2, chosen, color=COLOR_TRI, fill_opacity=1).set_stroke(BLACK, 2)
                    if add_polygon_if_unique(new_tri, new_layer):
                        self.play(Create(new_tri), run_time=0.1)

            all_tris = list(new_layer)  # expande para fora
            self.wait(0.2)

        self.wait(3)

    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo01')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/5tMZmvmbWxo"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>

      <div class="code-box" id="codigo002">
    <pre><code>
from manim import *
import numpy as np

class Tiling333333(Scene):
    def construct(self):
        self.camera.background_color = "#1e1e1e"
        L = 3  # lado do triângulo

        # Paleta de cores harmônica
        COLORS = color_gradient([ORANGE, YELLOW, RED, PINK], 20)

        # Sistema para evitar duplicatas
        existing_centers = set()
        def add_polygon_if_unique(poly, group_to_add):
            center = poly.get_center()
            rounded_center = (round(center[0], 2), round(center[1], 2))
            if rounded_center not in existing_centers:
                existing_centers.add(rounded_center)
                group_to_add.add(poly)
                return True
            return False

        # Função para criar triângulo equilátero
        def make_triangle(center, pointing_up=True, color=ORANGE):
            h = np.sqrt(3) * L / 2
            if pointing_up:
                p1 = center + np.array([-L/2, -h/3, 0])
                p2 = center + np.array([L/2, -h/3, 0])
                p3 = center + np.array([0, 2*h/3, 0])
            else:
                p1 = center + np.array([-L/2, h/3, 0])
                p2 = center + np.array([L/2, h/3, 0])
                p3 = center + np.array([0, -2*h/3, 0])
            return Polygon(p1, p2, p3, color=color, fill_opacity=1).set_stroke(BLACK, 0.8)

        # --- Triângulo inicial ---
        center_tri = make_triangle(np.array([0,0,0]), pointing_up=True, color=COLORS[0])
        layer = VGroup()
        add_polygon_if_unique(center_tri, layer)

        self.play(GrowFromCenter(center_tri))
        self.wait(0.3)

        # --- Construir várias camadas ---
        n_camadas = 7
        all_tris = [center_tri]

        for k in range(n_camadas):
            new_layer = VGroup()
            color = COLORS[k % len(COLORS)]  # cor varia por camada

            for tri in all_tris:
                verts = tri.get_vertices()
                for i in range(3):
                    p1, p2 = verts[i], verts[(i+1)%3]
                    mid = (p1 + p2) / 2
                    edge_vec = p2 - p1
                    side_len = np.linalg.norm(edge_vec)
                    height = side_len * np.sqrt(3) / 2
                    perp_vec = rotate_vector(edge_vec, -PI/2)
                    unit_perp = perp_vec / side_len

                    candidate1 = mid + unit_perp * height
                    candidate2 = mid - unit_perp * height
                    chosen = candidate1
                    if np.linalg.norm(chosen - tri.get_center()) < np.linalg.norm(candidate2 - tri.get_center()):
                        chosen = candidate2

                    new_tri = Polygon(p1, p2, chosen, color=color, fill_opacity=1).set_stroke(BLACK, 0.8)
                    add_polygon_if_unique(new_tri, new_layer)

            # animação estilizada: onda fluida
            self.play(
                LaggedStart(*[FadeIn(tri, scale=0.5) for tri in new_layer],
                            lag_ratio=0.05, run_time=1.5)
            )

            all_tris = list(new_layer)
            self.wait(0.2)

        self.wait(3)

    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo002')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/zsnHEwhG9E0"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>

                        
</section>
 </div>

      </header>
  <section class="section02">
  <h2>Ladrilhamento (4,4,4,4)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo02">
    <pre><code>
from manim import *
import numpy as np

class Tiling4444Styled(Scene):
    def construct(self):
        self.camera.background_color = "#000000"  # fundo escuro
        L = 2.2  # quadrados menores para caber mais

        COLORS = color_gradient([TEAL, BLUE], 20)

        def make_square(center, color):
            half = L / 2
            p1 = center + np.array([-half, -half, 0])
            p2 = center + np.array([half, -half, 0])
            p3 = center + np.array([half, half, 0])
            p4 = center + np.array([-half, half, 0])
            return Polygon(p1, p2, p3, p4, color=color, fill_opacity=1).set_stroke(BLACK, 1.5)

        n_camadas = 3

        # Camada 0
        sq0 = make_square(np.array([0,0,0]), COLORS[0])
        self.play(FadeIn(sq0, scale=0.5))
        self.wait(0.3)

        # Camadas externas
        for k in range(1, n_camadas+1):
            novos_quadrados = VGroup()
            for i in range(-k, k+1):
                for j in range(-k, k+1):
                    if abs(i) == k or abs(j) == k:
                        center = np.array([i*L, j*L, 0])
                        color = COLORS[(i+j+k) % len(COLORS)]
                        novos_quadrados.add(make_square(center, color))

            # Animação mais perceptível
            self.play(
                LaggedStart(*[FadeIn(sq, scale=0.5) for sq in novos_quadrados],
                            lag_ratio=0.5, run_time=1)
            )
            self.wait(3)

    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo02')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/2VCFexwejzQ"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
 </div>

      </header>
  <section class="section03">
  <h2>Ladrilhamento (6,6,6)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo03">
    <pre><code>
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo03')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/tIZmGaYscbw"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
 </div>
     <header class="main-header">
 <h2>Ladrilhamentos Bem Comportados Semirregulares</h2>
       </header>
    

<section class="section2">
  <h2>Ladrilhamento (3,12,12)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo1">
    <pre><code>
from manim import *
import numpy as np

class Tiling3_12_12(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#333333" # Fundo escuro para contraste
        L = 1.0  # Comprimento do lado dos polígonos

        # --- Cores ---
        COLOR_DODEC = BLUE
        COLOR_TRI = ORANGE

        # Conjunto para armazenar coordenadas de centros e evitar duplicatas
        existing_centers = set()

        # --- Funções Auxiliares ---
        def add_polygon_if_unique(poly, group_to_add):
            """Adiciona um polígono a um grupo se ele não for um duplicado."""
            center = poly.get_center()
            rounded_center = (round(center[0], 2), round(center[1], 2))
            
            if rounded_center not in existing_centers:
                existing_centers.add(rounded_center)
                group_to_add.add(poly)
                return True
            return False

        def attach_polygon(n_sides, color, target_side):
            """Cria e anexa um polígono a uma aresta específica."""
            radius = L / (2 * np.sin(PI / n_sides))
            poly = RegularPolygon(n=n_sides, radius=radius)
            poly.set_fill(color, opacity=1).set_stroke(BLACK, width=2)

            v = poly.get_vertices()
            p1, p2 = v[0], v[1]
            
            poly.shift(target_side[0] - p1)
            
            p2_new = p2 + (target_side[0] - p1)
            angle_target = angle_of_vector(target_side[1] - target_side[0])
            angle_current = angle_of_vector(p2_new - target_side[0])
            poly.rotate(angle_target - angle_current, about_point=target_side[0])
            
            return poly

        # --- Camada 0: Dodecágono Central ---
        dodecagon = RegularPolygon(n=12, radius=L / (2*np.sin(PI/12)))
        dodecagon.set_fill(COLOR_DODEC, opacity=1).set_stroke(BLACK, width=2)
        
        layer0_group = VGroup()
        add_polygon_if_unique(dodecagon, layer0_group)
        self.play(Create(layer0_group))
        self.wait(0.5)

        # --- Camada 1: Primeira Expansão (Dodecágonos e Triângulos) ---
        layer1_group = VGroup()
        layer1_polys_list = [] # Lista para iterar na próxima camada
        dodec_vertices = dodecagon.get_vertices()

        for i in range(12):
            # Inverte a aresta para construir para fora
            side = (dodec_vertices[(i + 1) % 12], dodec_vertices[i])
            
            if i % 2 == 0: # Arestas pares recebem dodecágonos
                new_poly = attach_polygon(12, COLOR_DODEC, side)
            else: # Arestas ímpares recebem triângulos
                new_poly = attach_polygon(3, COLOR_TRI, side)
            
            if add_polygon_if_unique(new_poly, layer1_group):
                layer1_polys_list.append(new_poly)

        self.play(Create(layer1_group), run_time=3)
        self.wait(0.5)
        
        # --- Camada 2: Segunda Expansão ---
        layer2_group = VGroup()
        for base_poly in layer1_polys_list:
            vertices = base_poly.get_vertices()
            num_sides = len(vertices)

            # Encontra a aresta "interna" (mais próxima do centro da cena)
            min_dist = float('inf')
            attached_edge_index = 0
            for i in range(num_sides):
                mid = (vertices[i] + vertices[(i + 1) % num_sides]) / 2
                dist = np.linalg.norm(mid)
                if dist < min_dist:
                    min_dist = dist
                    attached_edge_index = i
            
            # Expansão a partir de um TRIÂNGULO
            if num_sides == 3:
                # As 2 arestas livres recebem dodecágonos
                for offset in [1, 2]:
                    edge_index = (attached_edge_index + offset) % num_sides
                    side = (vertices[(edge_index + 1) % num_sides], vertices[edge_index])
                    new_dodec = attach_polygon(12, COLOR_DODEC, side)
                    add_polygon_if_unique(new_dodec, layer2_group)
            
            # Expansão a partir de um DODECÁGONO
            elif num_sides == 12:
                # As 9 arestas livres recebem um padrão alternado de D-T-D-T...
                for offset in range(2, 11): # As arestas com offset 0, 1 e 11 estão ocupadas
                    edge_index = (attached_edge_index + offset) % num_sides
                    side = (vertices[(edge_index + 1) % num_sides], vertices[edge_index])
                    
                    if offset % 2 == 0: # Posição par no padrão livre: Dodecágono
                         new_poly = attach_polygon(12, COLOR_DODEC, side)
                    else: # Posição ímpar no padrão livre: Triângulo
                         new_poly = attach_polygon(3, COLOR_TRI, side)
                    
                    add_polygon_if_unique(new_poly, layer2_group)

        self.play(Create(layer2_group), run_time=4)
        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo1')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/hGGUnIBu5Xc"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>

<section class="section3">
  <h2>Ladrilhamento (4,6,12)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo2">
    <pre><code>
from manim import *
import numpy as np

class Tiling124(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = WHITE  # 1. Fundo branco
        L = 1.0  # comprimento do lado dos polígonos

        all_polygons = VGroup()  # grupo para armazenar todos os polígonos

        # --- Função auxiliar para criar e posicionar polígonos ---
        def attach_polygon(n_sides, color, target_side, reference_center):
            radius = L / (2 * np.sin(PI / n_sides))
            poly = RegularPolygon(n=n_sides, radius=radius)
            poly.set_fill(color, opacity=1)
            poly.set_stroke(BLACK, width=2) # 1. Borda preta

            # alinhamento do lado
            v = poly.get_vertices()
            p1, p2 = v[0], v[1]

            # Translacao
            shift_vec = target_side[0] - p1
            poly.shift(shift_vec)
            p2_new = p2 + shift_vec

            # Rotação
            angle_target = np.angle(complex(*(target_side[1] - target_side[0])[:2]))
            angle_current = np.angle(complex(*(p2_new - target_side[0])[:2]))
            poly.rotate(angle_target - angle_current, about_point=target_side[0])

            # Garantir que fique para fora
            mid_side = (target_side[0] + target_side[1]) / 2
            center_poly = poly.get_center()
            outward_vec_ref = mid_side - reference_center
            outward_vec_poly = center_poly - mid_side
            if np.dot(outward_vec_poly, outward_vec_ref) < 0:
                poly.rotate(PI, about_point=mid_side)

            return poly

        # --- Função para evitar duplicatas ---
        def is_duplicate(poly, group):
            if not group:
                return False
            for p in group:
                if np.linalg.norm(poly.get_center() - p.get_center()) < 0.01:
                    return True
            return False

        # --- Dodecágono central ---
        dodecagon = RegularPolygon(n=12, radius=L / (2*np.sin(PI/12)))
        dodecagon.set_fill(BLUE, opacity=1)
        dodecagon.set_stroke(BLACK, width=2) # 1. Borda preta
        all_polygons.add(dodecagon)
        self.play(Create(dodecagon), run_time=1.5)

        # --- Primeira camada: quadrados e hexágonos nos vértices ---
        first_layer = VGroup()
        vertices = dodecagon.get_vertices()
        for i in range(12):
            v_prev = vertices[i-1]
            v_curr = vertices[i]
            v_next = vertices[(i+1)%12]

            if i % 2 == 0:
                square = attach_polygon(4, RED, (v_curr, v_next), dodecagon.get_center())
                first_layer.add(square)
                hexagon = attach_polygon(6, GREEN, (v_prev, v_curr), dodecagon.get_center())
                first_layer.add(hexagon)
            else:
                hexagon = attach_polygon(6, GREEN, (v_curr, v_next), dodecagon.get_center())
                first_layer.add(hexagon)
                square = attach_polygon(4, RED, (v_prev, v_curr), dodecagon.get_center())
                first_layer.add(square)

        all_polygons.add(*first_layer)
        self.play(Create(first_layer), run_time=2)

        # --- Segunda camada: expansão ---
        second_layer = VGroup()
        second_layer_polys_list = [] # Lista para guardar polígonos para a próxima camada
        for poly in first_layer:
            vertices = poly.get_vertices()
            num_sides = len(vertices)
            center_ref = dodecagon.get_center()

            min_dist = float('inf')
            attached_edge_index = 0
            for i in range(num_sides):
                mid = (vertices[i] + vertices[(i+1)%num_sides])/2
                dist = np.linalg.norm(mid - center_ref)
                if dist < min_dist:
                    min_dist = dist
                    attached_edge_index = i

            if num_sides == 4:
                free_edge_index = (attached_edge_index + 2) % 4
                side_free = (vertices[free_edge_index], vertices[(free_edge_index+1)%4])
                new_dode = attach_polygon(12, BLUE, side_free, poly.get_center())
                if not is_duplicate(new_dode, all_polygons):
                    second_layer.add(new_dode)
                    all_polygons.add(new_dode)
                    second_layer_polys_list.append(new_dode)
                
                for offset in [1, 3]:
                    lateral_edge_index = (attached_edge_index + offset) % 4
                    side_lateral = (vertices[lateral_edge_index], vertices[(lateral_edge_index+1)%4])
                    new_hexagon = attach_polygon(6, GREEN, side_lateral, poly.get_center())
                    if not is_duplicate(new_hexagon, all_polygons):
                        second_layer.add(new_hexagon)
                        all_polygons.add(new_hexagon)
                        second_layer_polys_list.append(new_hexagon)
            
            elif num_sides == 6:
                opposite_edge_index = (attached_edge_index + 3) % 6
                side_opposite = (vertices[opposite_edge_index], vertices[(opposite_edge_index+1)%6])
                new_square = attach_polygon(4, RED, side_opposite, poly.get_center())
                if not is_duplicate(new_square, all_polygons):
                    second_layer.add(new_square)
                    all_polygons.add(new_square)
                    second_layer_polys_list.append(new_square)

        self.play(Create(second_layer), run_time=3)
        self.wait(0.5)

        # --- 2. Terceira camada: completando os dodecágonos externos ---
        third_layer = VGroup()
        for base_poly in second_layer_polys_list:
            # Apenas expandir a partir dos novos dodecágonos
            if len(base_poly.get_vertices()) == 12:
                vertices = base_poly.get_vertices()
                
                # Encontra a aresta "interna", mais próxima do centro (0,0)
                min_dist = float('inf')
                attached_edge_index = 0
                for i in range(12):
                    mid = (vertices[i] + vertices[(i+1)%12])/2
                    dist = np.linalg.norm(mid)
                    if dist < min_dist:
                        min_dist = dist
                        attached_edge_index = i
                
                # Itera sobre as 11 arestas livres
                for offset in range(1, 12):
                    edge_index = (attached_edge_index + offset) % 12
                    side = (vertices[edge_index], vertices[(edge_index + 1) % 12])
                    
                    # Alterna entre hexágono e quadrado
                    if offset % 2 != 0: # Ímpar: Hexágono
                        new_poly = attach_polygon(6, GREEN, side, base_poly.get_center())
                    else: # Par: Quadrado
                        new_poly = attach_polygon(4, RED, side, base_poly.get_center())
                    
                    if not is_duplicate(new_poly, all_polygons):
                        third_layer.add(new_poly)
                        all_polygons.add(new_poly)
        
        self.play(Create(third_layer), run_time=4)
        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo2')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/zSOAJamGVpg"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>

<section class="section4">
  <h2>Ladrilhamento (3,12,12)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo3">
    <pre><code>
from manim import *
import numpy as np

class Tiling4_8_8(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#333333" # Fundo escuro para contraste
        L = 1.0  # Comprimento do lado dos polígonos

        # --- Cores ---
        COLOR_OCT = BLUE
        COLOR_SQUARE = RED

        # Conjunto para armazenar coordenadas de centros e evitar duplicatas
        existing_centers = set()

        # --- Funções Auxiliares ---
        def add_polygon_if_unique(poly, group_to_add):
            """Adiciona um polígono a um grupo se ele não for um duplicado."""
            center = poly.get_center()
            rounded_center = (round(center[0], 2), round(center[1], 2))
            
            if rounded_center not in existing_centers:
                existing_centers.add(rounded_center)
                group_to_add.add(poly)
                return True
            return False

        def attach_polygon(n_sides, color, target_side):
            """Cria e anexa um polígono a uma aresta específica."""
            radius = L / (2 * np.sin(PI / n_sides))
            poly = RegularPolygon(n=n_sides, radius=radius)
            poly.set_fill(color, opacity=1).set_stroke(BLACK, width=2)

            v = poly.get_vertices()
            p1, p2 = v[0], v[1]
            
            poly.shift(target_side[0] - p1)
            
            p2_new = p2 + (target_side[0] - p1)
            angle_target = angle_of_vector(target_side[1] - target_side[0])
            angle_current = angle_of_vector(p2_new - target_side[0])
            poly.rotate(angle_target - angle_current, about_point=target_side[0])
            
            return poly

        # --- Camada 0: Octógono Central ---
        octagon = RegularPolygon(n=8, radius=L / (2*np.sin(PI/8)))
        octagon.set_fill(COLOR_OCT, opacity=1).set_stroke(BLACK, width=2)
        
        layer0_group = VGroup()
        add_polygon_if_unique(octagon, layer0_group)
        self.play(Create(layer0_group))
        self.wait(0.5)

        # --- Camada 1: Primeira Expansão (Octógonos e Quadrados) ---
        layer1_group = VGroup()
        layer1_polys_list = [] # Lista para iterar na próxima camada
        oct_vertices = octagon.get_vertices()

        for i in range(8):
            # Inverte a aresta para construir para fora
            side = (oct_vertices[(i + 1) % 8], oct_vertices[i])
            
            if i % 2 == 0: # Arestas pares recebem octógonos
                new_poly = attach_polygon(8, COLOR_OCT, side)
            else: # Arestas ímpares recebem quadrados
                new_poly = attach_polygon(4, COLOR_SQUARE, side)
            
            if add_polygon_if_unique(new_poly, layer1_group):
                layer1_polys_list.append(new_poly)

        self.play(Create(layer1_group), run_time=3)
        self.wait(0.5)
        
        # --- Camada 2: Segunda Expansão ---
        layer2_group = VGroup()
        for base_poly in layer1_polys_list:
            vertices = base_poly.get_vertices()
            num_sides = len(vertices)

            # Encontra a aresta "interna" (mais próxima do centro da cena)
            min_dist = float('inf')
            attached_edge_index = 0
            for i in range(num_sides):
                mid = (vertices[i] + vertices[(i + 1) % num_sides]) / 2
                dist = np.linalg.norm(mid)
                if dist < min_dist:
                    min_dist = dist
                    attached_edge_index = i
            
            # Expansão a partir de um QUADRADO
            if num_sides == 4:
                # As 3 arestas livres recebem octógonos
                for offset in [1, 2, 3]:
                    edge_index = (attached_edge_index + offset) % num_sides
                    side = (vertices[(edge_index + 1) % num_sides], vertices[edge_index])
                    new_oct = attach_polygon(8, COLOR_OCT, side)
                    add_polygon_if_unique(new_oct, layer2_group)
            
            # Expansão a partir de um OCTÓGONO
            elif num_sides == 8:
                # As 5 arestas livres recebem um padrão alternado de O-S-O-S-O
                for offset in range(2, 7): # As arestas com offset 0, 1 e 7 estão ocupadas
                    edge_index = (attached_edge_index + offset) % num_sides
                    side = (vertices[(edge_index + 1) % num_sides], vertices[edge_index])
                    
                    if offset % 2 == 0: # Posição par no padrão livre: Octógono
                         new_poly = attach_polygon(8, COLOR_OCT, side)
                    else: # Posição ímpar no padrão livre: Quadrado
                         new_poly = attach_polygon(4, COLOR_SQUARE, side)
                    
                    add_polygon_if_unique(new_poly, layer2_group)

        self.play(Create(layer2_group), run_time=4)
        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo3')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/76kPLzGiE5Q"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>

<section class="section5">
  <h2>Ladrilhamento (3,4,6,4)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo4">
    <pre><code>
from manim import *
import numpy as np

class Tiling3464_Corrected(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#333333"
        L = 1.5  # Comprimento do lado dos polígonos

        # --- Cores ---
        COLOR_HEX = GREEN
        COLOR_SQUARE = RED
        COLOR_TRI = ORANGE

        # --- Etapa 1: Criar o Hexágono Central ---
        center_hex = RegularPolygon(n=6, radius=L)
        center_hex.set_fill(COLOR_HEX, opacity=1).set_stroke(BLACK, 2)

        self.play(Create(center_hex))
        self.wait(0.5)

        # --- Etapa 2: Construir a primeira camada de quadrados e triângulos ---
        layer1_squares = VGroup()
        layer1_triangles = VGroup()

        square_verts_list = []
        for i in range(6):
            p1 = center_hex.get_vertices()[i]
            p2 = center_hex.get_vertices()[(i + 1) % 6]

            edge_vector = p2 - p1
            perp_vector = rotate_vector(edge_vector, -PI / 2)

            p3 = p2 + perp_vector
            p4 = p1 + perp_vector
            square_verts_list.append([p1, p2, p3, p4])

        for i in range(6):
            verts_sq = square_verts_list[i]
            square = Polygon(*verts_sq, color=COLOR_SQUARE, fill_opacity=1).set_stroke(BLACK, 2)
            layer1_squares.add(square)

            verts_tri_prev_sq = square_verts_list[i-1]

            v1 = center_hex.get_vertices()[i]
            v2 = verts_tri_prev_sq[2]
            v3 = verts_sq[3]

            triangle = Polygon(v1, v2, v3, color=COLOR_TRI, fill_opacity=1).set_stroke(BLACK, 2)
            layer1_triangles.add(triangle)

        run_time_per_piece = 0.25
        for sq in layer1_squares:
            self.play(Create(sq), run_time=run_time_per_piece)
        for tri in layer1_triangles:
            self.play(Create(tri), run_time=run_time_per_piece)
        self.wait(0.5)

        # --- Etapa 3: Construir a segunda camada externa ---
        layer2_hexagons = VGroup()
        layer2_squares = VGroup()

        for i in range(6):
            verts_sq = square_verts_list[i]
            p1_hex = verts_sq[3] 
            p2_hex = verts_sq[2] 

            side_vector = p2_hex - p1_hex
            hex_points = [p1_hex, p2_hex]
            current_point = p2_hex
            angle = -PI / 3 
            for _ in range(4):
                side_vector = rotate_vector(side_vector, angle)
                current_point = current_point + side_vector
                hex_points.append(current_point)

            new_hex = Polygon(*hex_points, color=COLOR_HEX, fill_opacity=1).set_stroke(BLACK, 2)
            layer2_hexagons.add(new_hex)

        for tri in layer1_triangles:
            verts_tri = tri.get_vertices()
            distances = [np.linalg.norm(v) for v in verts_tri]
            inner_vertex_index = np.argmin(distances)

            p1_sq = verts_tri[(inner_vertex_index + 1) % 3]
            p2_sq = verts_tri[(inner_vertex_index + 2) % 3]

            edge_vector = p2_sq - p1_sq
            perp_vector = rotate_vector(edge_vector, -PI / 2) 
            p3_sq = p2_sq + perp_vector
            p4_sq = p1_sq + perp_vector

            new_square = Polygon(p1_sq, p2_sq, p3_sq, p4_sq, color=COLOR_SQUARE, fill_opacity=1).set_stroke(BLACK, 2)
            layer2_squares.add(new_square)

        for hx in layer2_hexagons:
            self.play(Create(hx), run_time=run_time_per_piece)
        for sq in layer2_squares:
            self.play(Create(sq), run_time=run_time_per_piece)

        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo4')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/tIZmGaYscbw"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>

<section class="section6">
  <h2>Ladrilhamento (3,6,3,6)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo5">
    <pre><code>
from manim import *
import numpy as np

class Tiling3636(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#333333"
        L = 1.5  # Comprimento do lado dos polígonos

        # --- Cores ---
        COLOR_HEX = GREEN
        COLOR_TRI = ORANGE
        
        # --- Sistema para evitar duplicatas ---
        existing_centers = set()
        def add_polygon_if_unique(poly, group_to_add):
            center = poly.get_center()
            rounded_center = (round(center[0], 2), round(center[1], 2))
            if rounded_center not in existing_centers:
                existing_centers.add(rounded_center)
                group_to_add.add(poly)
                return True
            return False

        # --- Etapa 1: Hexágono Central ---
        center_hex = RegularPolygon(n=6, radius=L)
        center_hex.set_fill(COLOR_HEX, opacity=1).set_stroke(BLACK, 2)
        add_polygon_if_unique(center_hex, VGroup())
        
        self.play(Create(center_hex))
        self.wait(0.5)

        # --- Etapa 2: Construir a primeira camada de triângulos ---
        layer1_triangles = VGroup()
        
        for i in range(6):
            p1 = center_hex.get_vertices()[i]
            p2 = center_hex.get_vertices()[(i + 1) % 6]
            
            edge_vector = p2 - p1
            side_length = np.linalg.norm(edge_vector)
            height = side_length * np.sqrt(3) / 2
            mid_point = (p1 + p2) / 2
            perp_vector = rotate_vector(edge_vector, -PI / 2)
            unit_perp_vector = perp_vector / side_length
            p3 = mid_point + unit_perp_vector * height
            
            triangle = Polygon(p1, p2, p3, color=COLOR_TRI, fill_opacity=1).set_stroke(BLACK, 2)
            add_polygon_if_unique(triangle, layer1_triangles)

        run_time_per_piece = 0.2
        for tri in layer1_triangles:
            self.play(Create(tri), run_time=run_time_per_piece)
        self.wait(0.5)

        # --- Etapa 3: Construir a segunda camada de hexágonos ---
        layer2_hexagons = VGroup()
        layer2_hexagons_list = []

        for tri in layer1_triangles:
            verts_tri = tri.get_vertices()
            
            midpoints = [np.linalg.norm((verts_tri[j] + verts_tri[(j + 1) % 3]) / 2) for j in range(3)]
            inner_edge_idx = np.argmin(midpoints)
            
            for offset in [1, 2]:
                edge_idx = (inner_edge_idx + offset) % 3
                p1 = verts_tri[(edge_idx + 1) % 3] 
                p2 = verts_tri[edge_idx]
                
                side_vector = p2 - p1
                hex_points = [p1, p2]
                current_point = p2
                angle = -PI / 3
                for _ in range(4):
                    side_vector = rotate_vector(side_vector, angle)
                    current_point = current_point + side_vector
                    hex_points.append(current_point)
                
                new_hex = Polygon(*hex_points, color=COLOR_HEX, fill_opacity=1).set_stroke(BLACK, 2)
                if add_polygon_if_unique(new_hex, layer2_hexagons):
                    layer2_hexagons_list.append(new_hex)

        for hx in layer2_hexagons:
            self.play(Create(hx), run_time=run_time_per_piece)
        self.wait(0.5)

        # --- Etapa 4: Preenchimento dos vãos com triângulos (MÉTODO À PROVA DE FALHAS) ---
        layer3_triangles = VGroup()
        
        # Itera sobre os triângulos da primeira camada, que servem de "âncora" para os vãos
        for tri_anchor in layer1_triangles:
            verts_anchor = tri_anchor.get_vertices()
            
            # 1. Encontra o vértice externo do triângulo-âncora. Este é o fundo do "V".
            outer_v_anchor = verts_anchor[np.argmax([np.linalg.norm(v) for v in verts_anchor])]

            # 2. Procura na lista de hexágonos quais os 2 que tocam neste vértice
            adjacent_hexagons = []
            for hex_l2 in layer2_hexagons_list:
                for v_hex in hex_l2.get_vertices():
                    if np.linalg.norm(v_hex - outer_v_anchor) < 0.01:
                        adjacent_hexagons.append(hex_l2)
                        break
            
            # Garante que encontramos exatamente 2 hexágonos
            if len(adjacent_hexagons) == 2:
                hex1, hex2 = adjacent_hexagons[0], adjacent_hexagons[1]
                
                # 3. Encontra os outros 2 vértices do triângulo
                
                # Para o hex1, encontra o vértice adjacente ao ponto de encontro que é mais externo
                verts1 = hex1.get_vertices()
                idx1 = np.where([np.allclose(v, outer_v_anchor) for v in verts1])[0][0]
                adj1_a, adj1_b = verts1[(idx1 - 1 + 6) % 6], verts1[(idx1 + 1) % 6]
                outer_v1 = adj1_a if np.linalg.norm(adj1_a) > np.linalg.norm(adj1_b) else adj1_b

                # Para o hex2, faz o mesmo
                verts2 = hex2.get_vertices()
                idx2 = np.where([np.allclose(v, outer_v_anchor) for v in verts2])[0][0]
                adj2_a, adj2_b = verts2[(idx2 - 1 + 6) % 6], verts2[(idx2 + 1) % 6]
                outer_v2 = adj2_a if np.linalg.norm(adj2_a) > np.linalg.norm(adj2_b) else adj2_b

                # 4. Cria o triângulo que preenche o vão
                new_triangle = Polygon(outer_v_anchor, outer_v1, outer_v2, color=COLOR_TRI, fill_opacity=1).set_stroke(BLACK, 2)
                add_polygon_if_unique(new_triangle, layer3_triangles)

        for tri in layer3_triangles:
            self.play(Create(tri), run_time=run_time_per_piece)
        


                # --- Etapa 5: Completar hexágonos externos com triângulos em todos os lados ---
        layer4_triangles = VGroup()

        def triangle_outside_edge(p1, p2):
            """Constrói triângulo equilátero externo ao lado (p1,p2)."""
            edge_vector = p2 - p1
            side_length = np.linalg.norm(edge_vector)
            mid_point = (p1 + p2) / 2
            perp_vector = rotate_vector(edge_vector, -PI / 2)
            unit_perp = perp_vector / side_length
            height = side_length * np.sqrt(3) / 2

            # O vetor normal aponta para fora ou para dentro.
            # Precisamos escolher o que aponta mais longe da origem (fora).
            candidate1 = mid_point + unit_perp * height
            candidate2 = mid_point - unit_perp * height
            chosen = candidate1 if np.linalg.norm(candidate1) > np.linalg.norm(candidate2) else candidate2

            return Polygon(p1, p2, chosen, color=COLOR_TRI, fill_opacity=1).set_stroke(BLACK, 2)

        # Para cada hexágono da camada 2
        for hexagon in layer2_hexagons_list:
            verts = hexagon.get_vertices()
            for i in range(6):
                p1, p2 = verts[i], verts[(i + 1) % 6]

                # Verifica se já existe algum triângulo ocupando esse lado
                already_filled = False
                for tri in list(layer1_triangles) + list(layer3_triangles) + list(layer4_triangles):
                    tri_verts = tri.get_vertices()
                    # Se dois vértices coincidem com (p1,p2), já tem triângulo
                    matches = sum([np.linalg.norm(tv - p1) < 0.01 or np.linalg.norm(tv - p2) < 0.01 for tv in tri_verts])
                    if matches >= 2:
                        already_filled = True
                        break

                if not already_filled:
                    new_tri = triangle_outside_edge(p1, p2)
                    if add_polygon_if_unique(new_tri, layer4_triangles):
                        self.play(Create(new_tri), run_time=run_time_per_piece)
        # --- Etapa 6: Adicionar hexágonos externos (encaixando nos triângulos) ---
        layer5_hexagons = VGroup()
        layer5_hexagons_list = []

        def hexagon_from_edge(p1, p2):
            """Constrói um hexágono regular externo compartilhando lado (p1,p2)."""
            side_vector = p2 - p1
            hex_points = [p1, p2]
            current_point = p2
            angle = -PI / 3
            for _ in range(4):
                side_vector = rotate_vector(side_vector, angle)
                current_point = current_point + side_vector
                hex_points.append(current_point)
            new_hex = Polygon(*hex_points, color=COLOR_HEX, fill_opacity=1).set_stroke(BLACK, 2)

            # decide se mantém ou reflete o hexágono
            # o centro deve ficar mais distante da origem do que o lado base
            base_mid = (p1 + p2) / 2
            if np.linalg.norm(new_hex.get_center()) < np.linalg.norm(base_mid):
                # inverte a rotação para gerar para fora
                hex_points = [p1, p2]
                current_point = p2
                angle = PI / 3
                side_vector = p2 - p1
                for _ in range(4):
                    side_vector = rotate_vector(side_vector, angle)
                    current_point = current_point + side_vector
                    hex_points.append(current_point)
                new_hex = Polygon(*hex_points, color=COLOR_HEX, fill_opacity=1).set_stroke(BLACK, 2)

            return new_hex

        for tri in layer4_triangles:
            verts = tri.get_vertices()
            # o vértice externo é o mais distante da origem
            outer_v = verts[np.argmax([np.linalg.norm(v) for v in verts])]

            # pega as arestas que têm esse vértice
            for edge in [(verts[0], verts[1]), (verts[1], verts[2]), (verts[2], verts[0])]:
                if not (np.allclose(outer_v, edge[0]) or np.allclose(outer_v, edge[1])):
                    continue
                p1, p2 = edge

                new_hex = hexagon_from_edge(p1, p2)
                if add_polygon_if_unique(new_hex, layer5_hexagons):
                    layer5_hexagons_list.append(new_hex)

        for hx in layer5_hexagons:
            self.play(Create(hx), run_time=run_time_per_piece)

        # --- Etapa 7: Completar hexágonos externos da camada 5 com triângulos ---
        layer6_triangles = VGroup()

        def triangle_outside_edge(p1, p2):
            """Constrói triângulo equilátero externo ao lado (p1,p2)."""
            edge_vector = p2 - p1
            side_length = np.linalg.norm(edge_vector)
            mid_point = (p1 + p2) / 2
            perp_vector = rotate_vector(edge_vector, -PI / 2)
            unit_perp = perp_vector / side_length
            height = side_length * np.sqrt(3) / 2

            # escolher o ponto externo (mais longe da origem)
            candidate1 = mid_point + unit_perp * height
            candidate2 = mid_point - unit_perp * height
            chosen = candidate1 if np.linalg.norm(candidate1) > np.linalg.norm(candidate2) else candidate2

            return Polygon(p1, p2, chosen, color=COLOR_TRI, fill_opacity=1).set_stroke(BLACK, 2)

        for hexagon in layer5_hexagons_list:
            verts = hexagon.get_vertices()
            for i in range(6):
                p1, p2 = verts[i], verts[(i + 1) % 6]

                # verifica se já tem triângulo nesse lado
                already_filled = False
                for tri in list(layer1_triangles) + list(layer3_triangles) + list(layer4_triangles) + list(layer6_triangles):
                    tri_verts = tri.get_vertices()
                    matches = sum([np.linalg.norm(tv - p1) < 0.01 or np.linalg.norm(tv - p2) < 0.01 for tv in tri_verts])
                    if matches >= 2:
                        already_filled = True
                        break

                if not already_filled:
                    new_tri = triangle_outside_edge(p1, p2)
                    if add_polygon_if_unique(new_tri, layer6_triangles):
                        self.play(Create(new_tri), run_time=run_time_per_piece)

        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo5')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/zds6ki2IUEc"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>


<section class="section7">
  <h2>Ladrilhamento (4,3,3,4)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo6">
    <pre><code>
from manim import *
import numpy as np

class Tiling33344_GridExpand(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#333333"
        L = 1.0  # Comprimento do lado dos polígonos

        # --- Cores ---
        COLOR_SQUARE = ORANGE
        COLOR_TRI = PINK
        
        # --- Função Auxiliar ---
        def build_triangle_on_edge(p_start, p_end, color, direction='ccw'):
            side_length = np.linalg.norm(p_end - p_start)
            mid = (p_start + p_end) / 2
            edge = p_end - p_start
            rotation = PI/2 if direction == 'ccw' else -PI/2
            height_vec = rotate_vector(edge, rotation) * np.sqrt(3)/2
            p_new = mid + height_vec
            return Polygon(p_start, p_end, p_new, color=color, fill_opacity=1).set_stroke(BLACK, 2)
        
        all_polys = VGroup()
        
        # --- Parâmetros da Grade (VALORES AUMENTADOS) ---
        num_cols = 21 # Antes era 11
        num_rows = 11 # Antes era 7

        h_tri = L * np.sqrt(3) / 2
        
        # Iterar para construir as linhas de formas
        for j in range(-num_rows // 2, num_rows // 2 + 1):
            y_offset = j * (L + h_tri)
            
            if j % 2 == 0: 
                x_start = -(num_cols * L) / 2 
            else: 
                x_start = -(num_cols * L) / 2 + L/2 

            for i in range(num_cols):
                sq = Square(side_length=L, color=COLOR_SQUARE, fill_opacity=1).set_stroke(BLACK, 2)
                sq.move_to(np.array([x_start + i * L, y_offset, 0]))
                all_polys.add(sq)

            if j < (num_rows // 2):
                for i in range(num_cols - 1):
                    p1_up = np.array([x_start + i * L + L/2, y_offset + L/2, 0])
                    p2_up = np.array([x_start + (i+1) * L + L/2, y_offset + L/2, 0])
                    tri_up = build_triangle_on_edge(p1_up, p2_up, COLOR_TRI, direction='ccw')
                    all_polys.add(tri_up)
                
                for i in range(num_cols - 1):
                    p1_down = np.array([x_start + i * L + L/2, y_offset - L/2, 0])
                    p2_down = np.array([x_start + (i+1) * L + L/2, y_offset - L/2, 0])
                    tri_down = build_triangle_on_edge(p1_down, p2_down, COLOR_TRI, direction='cw')
                    all_polys.add(tri_down)

        # Remove duplicatas
        unique_polys = VGroup()
        centers_added = set()
        for poly in all_polys:
            c = tuple(np.round(poly.get_center(), 3))
            if c not in centers_added:
                unique_polys.add(poly)
                centers_added.add(c)
        all_polys = unique_polys

        # Centraliza e ajusta a escala AUTOMATICAMENTE para caber na tela
        all_polys.center()
        # Define a largura desejada (um pouco menor que a tela para ter margem)
        desired_width = 13 
        current_width = all_polys.get_width()
        if current_width > 0:
            all_polys.scale(desired_width / current_width)

        # --- Animação: Crescer do Centro para Fora ---
        sorted_polys = sorted(all_polys, key=lambda p: np.linalg.norm(p.get_center()))

        self.play(LaggedStart(*[Create(p) for p in sorted_polys], lag_ratio=0.005, run_time=12))
        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo6')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/OW27Jt4eR10"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>

    <section class="section8">
  <h2>Ladrilhamento (3,3,3,6)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo7">
    <pre><code>
from manim import *
import numpy as np

class EstrelaBase(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#000000"
        LADO = 2.0
        
        # Cores
        COR_HEXAGONO = BLUE_E
        COR_TRIANGULOS = PINK 

        # --- PARTE 1: DESENHAR O HEXÁGONO CENTRAL ---
        hexagono = RegularPolygon(n=6, radius=LADO) 
        hexagono.set_fill(COR_HEXAGONO, opacity=1.0)
        hexagono.set_stroke(WHITE, width=3)

        self.play(Create(hexagono))
        self.wait(0.25)

        # --- PARTE 2: DESENHAR OS TRIÂNGULOS DA CAMADA 1 ---
        grupo_triangulos_camada1 = VGroup()
        pontos_externos_recuados = []

        for i in range(6):
            ponto1 = hexagono.get_vertices()[i]
            ponto2 = hexagono.get_vertices()[(i + 1) % 6]

            vetor_do_lado = ponto2 - ponto1
            ponto_medio = (ponto1 + ponto2) / 2
            vetor_normal = rotate_vector(vetor_do_lado, -PI / 2)
            altura = LADO * np.sqrt(3) / 2
            ponto3 = ponto_medio + normalize(vetor_normal) * altura
            
            pontos_externos_recuados.append(ponto3)

            triangulo = Polygon(ponto1, ponto2, ponto3)
            grupo_triangulos_camada1.add(triangulo)

        grupo_triangulos_camada1.set_fill(COR_TRIANGULOS, opacity=1.0).set_stroke(WHITE, width=3)
        self.play(Create(grupo_triangulos_camada1))
        self.wait(0.25)

        # --- PARTE 3: PREENCHER OS VÃOS (CAMADA 2) ---
        grupo_triangulos_camada2 = VGroup()
        pontos_externos_pontudos = []

        for i in range(6):
            vertice_do_hexagono = hexagono.get_vertices()[i]
            ponta_externa_anterior = pontos_externos_recuados[i - 1]
            ponta_externa_atual = pontos_externos_recuados[i]

            vetor_do_centro_ao_vertice = vertice_do_hexagono - hexagono.get_center()
            novo_ponto_externo = vertice_do_hexagono + vetor_do_centro_ao_vertice
            
            pontos_externos_pontudos.append(novo_ponto_externo)

            triangulo1 = Polygon(vertice_do_hexagono, ponta_externa_anterior, novo_ponto_externo)
            triangulo2 = Polygon(vertice_do_hexagono, novo_ponto_externo, ponta_externa_atual)
            grupo_triangulos_camada2.add(triangulo1, triangulo2)

        grupo_triangulos_camada2.set_fill(COR_TRIANGULOS, opacity=1.0).set_stroke(WHITE, width=3)
        self.play(Create(grupo_triangulos_camada2))
        self.wait(0.25)

        # --- PARTE 4: ADICIONAR TRIÂNGULOS (CAMADA 3) ---
        grupo_triangulos_camada3 = VGroup()

        for i in range(6):
            p1 = pontos_externos_recuados[i]
            p2 = pontos_externos_pontudos[i]

            vetor_do_lado = p2 - p1
            ponto_medio = (p1 + p2) / 2
            vetor_normal = rotate_vector(vetor_do_lado, PI / 2)
            altura = LADO * np.sqrt(3) / 2
            p3 = ponto_medio + normalize(vetor_normal) * altura

            novo_triangulo = Polygon(p1, p2, p3)
            novo_triangulo.set_fill(COR_TRIANGULOS, opacity=1.0).set_stroke(WHITE, width=3)
            grupo_triangulos_camada3.add(novo_triangulo)
            
        self.play(DrawBorderThenFill(grupo_triangulos_camada3))
        self.wait(0.25)
        # --- PARTE 5: ADICIONAR HEXÁGONOS ALINHADOS AOS TRIÂNGULOS ---
        grupo_hexagonos_camada4 = VGroup()
        centro_principal = hexagono.get_center()

        # função auxiliar: ângulo assinado entre vetores 2D (u -> v)
        def signed_angle(u, v):
            cross = u[0]*v[1] - u[1]*v[0]
            dot = u[0]*v[0] + u[1]*v[1]
            return np.arctan2(cross, dot)

        for i in range(6):
            ponto_alvo = pontos_externos_pontudos[i]   # onde os 4 triângulos se encontram

            # candidatos aos pontos "recuados" adjacentes a esse vértice
            recuado_cw = pontos_externos_recuados[i]      # lado (i, i+1)
            recuado_ccw = pontos_externos_recuados[i - 1] # lado (i-1, i)

            # direção radial (do centro principal para o ponto_alvo)
            direcao_radial = normalize(ponto_alvo - centro_principal)

            # decidir qual recuado está no sentido horário relativo à direcao_radial
            ang1 = signed_angle(direcao_radial, recuado_cw - ponto_alvo)
            ang2 = signed_angle(direcao_radial, recuado_ccw - ponto_alvo)
            # o que tiver ângulo negativo é o clockwise (sentido horário) em relação à direcao_radial
            if ang1 < 0:
                recuado_horario = recuado_cw
            else:
                recuado_horario = recuado_ccw

            # cria hexágono (no centro) e coloca um vértice sobre ponto_alvo
            hex_externo = RegularPolygon(n=6, radius=LADO)
            verts = hex_externo.get_vertices()
            k = 0  # índice do vértice do hexágono que vamos fazer coincidir com ponto_alvo
            desloc = ponto_alvo - verts[k]
            hex_externo.shift(desloc)

            # vetor de aresta atual (do vértice k para k+1) após o shift
            v_k = hex_externo.get_vertices()[k]
            v_k1 = hex_externo.get_vertices()[(k + 1) % 6]
            edge_current = v_k1 - v_k

            # vetor alvo: do vértice (ponto_alvo) até o ponto recuado do triângulo horário
            target_edge = recuado_horario - ponto_alvo

            # rotaciona o hexágono em torno do ponto_alvo para alinhar a aresta com o triângulo horário
            ang_edge = signed_angle(edge_current, target_edge)
            hex_externo.rotate(ang_edge, about_point=ponto_alvo)

            # estilo e adicionar ao grupo
            hex_externo.set_fill(COR_HEXAGONO, opacity=1.0).set_stroke(WHITE, width=3)
            grupo_hexagonos_camada4.add(hex_externo)

        self.play(Create(grupo_hexagonos_camada4))
        self.wait(2)
        # --- PARTE 6: ADICIONAR TRIÂNGULOS NOS NOVOS HEXÁGONOS ---
        grupo_triangulos_camada5 = VGroup()

        for hex_externo in grupo_hexagonos_camada4:
            vertices = hex_externo.get_vertices()

            for i in range(6):
                p1 = vertices[i]
                p2 = vertices[(i + 1) % 6]

                # calcula o ponto externo (igual na Parte 2)
                vetor_lado = p2 - p1
                ponto_medio = (p1 + p2) / 2
                vetor_normal = rotate_vector(vetor_lado, -PI/2)  # sempre para fora
                altura = LADO * np.sqrt(3) / 2
                p3 = ponto_medio + normalize(vetor_normal) * altura

                triangulo = Polygon(p1, p2, p3)
                triangulo.set_fill(COR_TRIANGULOS, opacity=1.0).set_stroke(WHITE, width=3)
                grupo_triangulos_camada5.add(triangulo)

        self.play(Create(grupo_triangulos_camada5))
        self.wait(2)
        # --- PARTE 7 (CORRIGIDA): COMPLETAR VÉRTICES SEM SOBREPOR HEXÁGONOS ---
        grupo_triangulos_extra = VGroup()
        altura = LADO * np.sqrt(3) / 2  # altura do triângulo equilátero
        eps_dup = 1e-3  # tolerância para evitar duplicatas

        # teste ponto dentro de polígono (ray-casting) — espera vértices em 2D (x,y)
        def point_in_polygon(pt, poly_verts_2d):
            x, y = float(pt[0]), float(pt[1])
            inside = False
            n = len(poly_verts_2d)
            for i in range(n):
                xi, yi = float(poly_verts_2d[i][0]), float(poly_verts_2d[i][1])
                xj, yj = float(poly_verts_2d[(i + 1) % n][0]), float(poly_verts_2d[(i + 1) % n][1])
                intersect = ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
                if intersect:
                    inside = not inside
            return inside

        # centroids de triângulos já colocados (camada5) para evitar recriar os mesmos
        existing_centroids = []
        for tri in grupo_triangulos_camada5:
            verts_tri = np.array([v[:2] for v in tri.get_vertices()])
            existing_centroids.append(np.mean(verts_tri, axis=0))

        # loop por cada hexágono externo já criado
        for hex_externo in grupo_hexagonos_camada4:
            verts3 = hex_externo.get_vertices()                     # lista de 3D verts
            verts = [np.array([v[0], v[1]]) for v in verts3]        # 2D verts
            center_hex = np.array([hex_externo.get_center()[0], hex_externo.get_center()[1]])

            # para cada vértice do hexágono, gerar candidatos em passos de 60°
            for j, v in enumerate(verts):
                # recomputa os pontos externos adjacentes (mesma fórmula usada antes)
                p_prev = verts[(j - 1) % 6]
                p_next = verts[(j + 1) % 6]

                def external_point(a, b):
                    side = b - a
                    mid = (a + b) / 2
                    # rota 90°; garantir que normal aponte para fora do hexágono
                    normal3 = rotate_vector(np.array([side[0], side[1], 0]), -PI / 2)
                    normal2 = np.array([normal3[0], normal3[1]])
                    if np.dot(normal2, mid - center_hex) < 0:
                        normal2 = -normal2
                    return mid + (normal2 / np.linalg.norm(normal2)) * altura

                ext_prev = external_point(p_prev, v)
                # usamos ext_prev como referência angular inicial
                theta_base = np.arctan2(ext_prev[1] - v[1], ext_prev[0] - v[0])

                # gerar 6 candidatos (passos de 60°); adicionar só os que NÃO caem dentro do hexágono
                for k in range(6):
                    ang = theta_base + k * (PI / 3)
                    p2 = v + np.array([np.cos(ang), np.sin(ang)]) * LADO
                    p3 = v + np.array([np.cos(ang + PI / 3), np.sin(ang + PI / 3)]) * LADO
                    centroid = (v + p2 + p3) / 3

                    # ignora se centróide está dentro do próprio hexágono (evita sobreposição)
                    if point_in_polygon(centroid, verts):
                        continue

                    # ignora se já existe triângulo muito próximo (dup)
                    dup = False
                    for c in existing_centroids:
                        if np.linalg.norm(centroid - c) < 0.1:  # 0.1 é margem razoável
                            dup = True
                            break
                    if dup:
                        continue

                    # cria e adiciona triângulo
                    tri = Polygon(np.array([v[0], v[1], 0]),
                                  np.array([p2[0], p2[1], 0]),
                                  np.array([p3[0], p3[1], 0]))
                    tri.set_fill(COR_TRIANGULOS, opacity=1.0).set_stroke(WHITE, width=3)
                    grupo_triangulos_extra.add(tri)
                    existing_centroids.append(centroid)

        self.play(Create(grupo_triangulos_extra))
        self.wait(3)

    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo7')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/M4w_lTshuYA"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>

  <section class="section9">
  <h2>Ladrilhamento (3,6,3,6)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo8">
    <pre><code>
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo8')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/tIZmGaYscbw"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
 </div>
                    
</body>
</html>
