<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google-site-verification" content="LiYCKidjfsyxb615zTwvCFEzp2_DPelhKscx3tpmVgU" />
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <title>Ladrilhamentos</title>
</head>
<body>
 <div id="navbar"></div> <!-- Aqui será inserida a barra de navegação -->

    <script>
        // Carregar a navegação automaticamente
        fetch("navbar.html")
            .then(response => response.text())
            .then(data => document.getElementById("navbar").innerHTML = data);
    </script>

    <!-- Cabeçalho -->
    <header class="main-header">
 <h1>Animações de Ladrilhamentos Bem Comportados com manim e IA</h1>
       </header>
    <section class="section1">
      <p style="text-align: justify;">
    Nesta seção, disponibilizo vídeos e os códigos-fonte correspondentes de algumas construções matemáticas que realizei.

As animações foram feitas em Python com a biblioteca Manim. Para a elaboração dos scripts, utilizei o ChatGPT como ferramenta, fornecendo os comandos e fazendo os ajustes necessários até chegar ao resultado final.

O tema explorado são os ladrilhamentos bem-comportados. De forma rápida, um ladrilhamento é 'bem-comportado' quando preenche o plano perfeitamente, sem falhas ou sobreposições, usando apenas polígonos regulares, com a interseção sendo apenas um lado ou vértice e a distribuição de polígonos em cada vértice é sempre a mesma.
      
      Existem 11 tipos de ladrilhamentos bem comportados. Dentre eles, três são formados por polígonos regulares de um único tipo: o triangular, com padrão (3,3,3,3,3,3); o quadrado, com padrão (4,4,4,4); e o hexagonal, com padrão (6,6,6). Os oito restantes são formados por dois ou mais tipos de polígonos regulares, sendo eles: (3,12,12), (4,6,12), (4,8,8), (3,4,6,4), (3,6,3,6), (3,3,3,4,4), (3,3,3,3,6) e (3,4,3,3,4). A seguir, apresentam-se os códigos utilizados e os vídeos renderizados correspondentes a cada construção.</p>

    </section>
    

<section class="section2">
  <h2>Ladrilhamento (3,12,12)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo1">
    <pre><code>
from manim import *
import numpy as np

class Tiling3_12_12(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#333333" # Fundo escuro para contraste
        L = 1.0  # Comprimento do lado dos polígonos

        # --- Cores ---
        COLOR_DODEC = BLUE
        COLOR_TRI = ORANGE

        # Conjunto para armazenar coordenadas de centros e evitar duplicatas
        existing_centers = set()

        # --- Funções Auxiliares ---
        def add_polygon_if_unique(poly, group_to_add):
            """Adiciona um polígono a um grupo se ele não for um duplicado."""
            center = poly.get_center()
            rounded_center = (round(center[0], 2), round(center[1], 2))
            
            if rounded_center not in existing_centers:
                existing_centers.add(rounded_center)
                group_to_add.add(poly)
                return True
            return False

        def attach_polygon(n_sides, color, target_side):
            """Cria e anexa um polígono a uma aresta específica."""
            radius = L / (2 * np.sin(PI / n_sides))
            poly = RegularPolygon(n=n_sides, radius=radius)
            poly.set_fill(color, opacity=1).set_stroke(BLACK, width=2)

            v = poly.get_vertices()
            p1, p2 = v[0], v[1]
            
            poly.shift(target_side[0] - p1)
            
            p2_new = p2 + (target_side[0] - p1)
            angle_target = angle_of_vector(target_side[1] - target_side[0])
            angle_current = angle_of_vector(p2_new - target_side[0])
            poly.rotate(angle_target - angle_current, about_point=target_side[0])
            
            return poly

        # --- Camada 0: Dodecágono Central ---
        dodecagon = RegularPolygon(n=12, radius=L / (2*np.sin(PI/12)))
        dodecagon.set_fill(COLOR_DODEC, opacity=1).set_stroke(BLACK, width=2)
        
        layer0_group = VGroup()
        add_polygon_if_unique(dodecagon, layer0_group)
        self.play(Create(layer0_group))
        self.wait(0.5)

        # --- Camada 1: Primeira Expansão (Dodecágonos e Triângulos) ---
        layer1_group = VGroup()
        layer1_polys_list = [] # Lista para iterar na próxima camada
        dodec_vertices = dodecagon.get_vertices()

        for i in range(12):
            # Inverte a aresta para construir para fora
            side = (dodec_vertices[(i + 1) % 12], dodec_vertices[i])
            
            if i % 2 == 0: # Arestas pares recebem dodecágonos
                new_poly = attach_polygon(12, COLOR_DODEC, side)
            else: # Arestas ímpares recebem triângulos
                new_poly = attach_polygon(3, COLOR_TRI, side)
            
            if add_polygon_if_unique(new_poly, layer1_group):
                layer1_polys_list.append(new_poly)

        self.play(Create(layer1_group), run_time=3)
        self.wait(0.5)
        
        # --- Camada 2: Segunda Expansão ---
        layer2_group = VGroup()
        for base_poly in layer1_polys_list:
            vertices = base_poly.get_vertices()
            num_sides = len(vertices)

            # Encontra a aresta "interna" (mais próxima do centro da cena)
            min_dist = float('inf')
            attached_edge_index = 0
            for i in range(num_sides):
                mid = (vertices[i] + vertices[(i + 1) % num_sides]) / 2
                dist = np.linalg.norm(mid)
                if dist < min_dist:
                    min_dist = dist
                    attached_edge_index = i
            
            # Expansão a partir de um TRIÂNGULO
            if num_sides == 3:
                # As 2 arestas livres recebem dodecágonos
                for offset in [1, 2]:
                    edge_index = (attached_edge_index + offset) % num_sides
                    side = (vertices[(edge_index + 1) % num_sides], vertices[edge_index])
                    new_dodec = attach_polygon(12, COLOR_DODEC, side)
                    add_polygon_if_unique(new_dodec, layer2_group)
            
            # Expansão a partir de um DODECÁGONO
            elif num_sides == 12:
                # As 9 arestas livres recebem um padrão alternado de D-T-D-T...
                for offset in range(2, 11): # As arestas com offset 0, 1 e 11 estão ocupadas
                    edge_index = (attached_edge_index + offset) % num_sides
                    side = (vertices[(edge_index + 1) % num_sides], vertices[edge_index])
                    
                    if offset % 2 == 0: # Posição par no padrão livre: Dodecágono
                         new_poly = attach_polygon(12, COLOR_DODEC, side)
                    else: # Posição ímpar no padrão livre: Triângulo
                         new_poly = attach_polygon(3, COLOR_TRI, side)
                    
                    add_polygon_if_unique(new_poly, layer2_group)

        self.play(Create(layer2_group), run_time=4)
        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo1')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/hGGUnIBu5Xc"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>

<section class="section3">
  <h2>Ladrilhamento (4,6,12)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo2">
    <pre><code>
from manim import *
import numpy as np

class Tiling124(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = WHITE  # 1. Fundo branco
        L = 1.0  # comprimento do lado dos polígonos

        all_polygons = VGroup()  # grupo para armazenar todos os polígonos

        # --- Função auxiliar para criar e posicionar polígonos ---
        def attach_polygon(n_sides, color, target_side, reference_center):
            radius = L / (2 * np.sin(PI / n_sides))
            poly = RegularPolygon(n=n_sides, radius=radius)
            poly.set_fill(color, opacity=1)
            poly.set_stroke(BLACK, width=2) # 1. Borda preta

            # alinhamento do lado
            v = poly.get_vertices()
            p1, p2 = v[0], v[1]

            # Translacao
            shift_vec = target_side[0] - p1
            poly.shift(shift_vec)
            p2_new = p2 + shift_vec

            # Rotação
            angle_target = np.angle(complex(*(target_side[1] - target_side[0])[:2]))
            angle_current = np.angle(complex(*(p2_new - target_side[0])[:2]))
            poly.rotate(angle_target - angle_current, about_point=target_side[0])

            # Garantir que fique para fora
            mid_side = (target_side[0] + target_side[1]) / 2
            center_poly = poly.get_center()
            outward_vec_ref = mid_side - reference_center
            outward_vec_poly = center_poly - mid_side
            if np.dot(outward_vec_poly, outward_vec_ref) < 0:
                poly.rotate(PI, about_point=mid_side)

            return poly

        # --- Função para evitar duplicatas ---
        def is_duplicate(poly, group):
            if not group:
                return False
            for p in group:
                if np.linalg.norm(poly.get_center() - p.get_center()) < 0.01:
                    return True
            return False

        # --- Dodecágono central ---
        dodecagon = RegularPolygon(n=12, radius=L / (2*np.sin(PI/12)))
        dodecagon.set_fill(BLUE, opacity=1)
        dodecagon.set_stroke(BLACK, width=2) # 1. Borda preta
        all_polygons.add(dodecagon)
        self.play(Create(dodecagon), run_time=1.5)

        # --- Primeira camada: quadrados e hexágonos nos vértices ---
        first_layer = VGroup()
        vertices = dodecagon.get_vertices()
        for i in range(12):
            v_prev = vertices[i-1]
            v_curr = vertices[i]
            v_next = vertices[(i+1)%12]

            if i % 2 == 0:
                square = attach_polygon(4, RED, (v_curr, v_next), dodecagon.get_center())
                first_layer.add(square)
                hexagon = attach_polygon(6, GREEN, (v_prev, v_curr), dodecagon.get_center())
                first_layer.add(hexagon)
            else:
                hexagon = attach_polygon(6, GREEN, (v_curr, v_next), dodecagon.get_center())
                first_layer.add(hexagon)
                square = attach_polygon(4, RED, (v_prev, v_curr), dodecagon.get_center())
                first_layer.add(square)

        all_polygons.add(*first_layer)
        self.play(Create(first_layer), run_time=2)

        # --- Segunda camada: expansão ---
        second_layer = VGroup()
        second_layer_polys_list = [] # Lista para guardar polígonos para a próxima camada
        for poly in first_layer:
            vertices = poly.get_vertices()
            num_sides = len(vertices)
            center_ref = dodecagon.get_center()

            min_dist = float('inf')
            attached_edge_index = 0
            for i in range(num_sides):
                mid = (vertices[i] + vertices[(i+1)%num_sides])/2
                dist = np.linalg.norm(mid - center_ref)
                if dist < min_dist:
                    min_dist = dist
                    attached_edge_index = i

            if num_sides == 4:
                free_edge_index = (attached_edge_index + 2) % 4
                side_free = (vertices[free_edge_index], vertices[(free_edge_index+1)%4])
                new_dode = attach_polygon(12, BLUE, side_free, poly.get_center())
                if not is_duplicate(new_dode, all_polygons):
                    second_layer.add(new_dode)
                    all_polygons.add(new_dode)
                    second_layer_polys_list.append(new_dode)
                
                for offset in [1, 3]:
                    lateral_edge_index = (attached_edge_index + offset) % 4
                    side_lateral = (vertices[lateral_edge_index], vertices[(lateral_edge_index+1)%4])
                    new_hexagon = attach_polygon(6, GREEN, side_lateral, poly.get_center())
                    if not is_duplicate(new_hexagon, all_polygons):
                        second_layer.add(new_hexagon)
                        all_polygons.add(new_hexagon)
                        second_layer_polys_list.append(new_hexagon)
            
            elif num_sides == 6:
                opposite_edge_index = (attached_edge_index + 3) % 6
                side_opposite = (vertices[opposite_edge_index], vertices[(opposite_edge_index+1)%6])
                new_square = attach_polygon(4, RED, side_opposite, poly.get_center())
                if not is_duplicate(new_square, all_polygons):
                    second_layer.add(new_square)
                    all_polygons.add(new_square)
                    second_layer_polys_list.append(new_square)

        self.play(Create(second_layer), run_time=3)
        self.wait(0.5)

        # --- 2. Terceira camada: completando os dodecágonos externos ---
        third_layer = VGroup()
        for base_poly in second_layer_polys_list:
            # Apenas expandir a partir dos novos dodecágonos
            if len(base_poly.get_vertices()) == 12:
                vertices = base_poly.get_vertices()
                
                # Encontra a aresta "interna", mais próxima do centro (0,0)
                min_dist = float('inf')
                attached_edge_index = 0
                for i in range(12):
                    mid = (vertices[i] + vertices[(i+1)%12])/2
                    dist = np.linalg.norm(mid)
                    if dist < min_dist:
                        min_dist = dist
                        attached_edge_index = i
                
                # Itera sobre as 11 arestas livres
                for offset in range(1, 12):
                    edge_index = (attached_edge_index + offset) % 12
                    side = (vertices[edge_index], vertices[(edge_index + 1) % 12])
                    
                    # Alterna entre hexágono e quadrado
                    if offset % 2 != 0: # Ímpar: Hexágono
                        new_poly = attach_polygon(6, GREEN, side, base_poly.get_center())
                    else: # Par: Quadrado
                        new_poly = attach_polygon(4, RED, side, base_poly.get_center())
                    
                    if not is_duplicate(new_poly, all_polygons):
                        third_layer.add(new_poly)
                        all_polygons.add(new_poly)
        
        self.play(Create(third_layer), run_time=4)
        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo2')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/zSOAJamGVpg"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>

<section class="section4">
  <h2>Ladrilhamento (3,12,12)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo3">
    <pre><code>
from manim import *
import numpy as np

class Tiling4_8_8(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#333333" # Fundo escuro para contraste
        L = 1.0  # Comprimento do lado dos polígonos

        # --- Cores ---
        COLOR_OCT = BLUE
        COLOR_SQUARE = RED

        # Conjunto para armazenar coordenadas de centros e evitar duplicatas
        existing_centers = set()

        # --- Funções Auxiliares ---
        def add_polygon_if_unique(poly, group_to_add):
            """Adiciona um polígono a um grupo se ele não for um duplicado."""
            center = poly.get_center()
            rounded_center = (round(center[0], 2), round(center[1], 2))
            
            if rounded_center not in existing_centers:
                existing_centers.add(rounded_center)
                group_to_add.add(poly)
                return True
            return False

        def attach_polygon(n_sides, color, target_side):
            """Cria e anexa um polígono a uma aresta específica."""
            radius = L / (2 * np.sin(PI / n_sides))
            poly = RegularPolygon(n=n_sides, radius=radius)
            poly.set_fill(color, opacity=1).set_stroke(BLACK, width=2)

            v = poly.get_vertices()
            p1, p2 = v[0], v[1]
            
            poly.shift(target_side[0] - p1)
            
            p2_new = p2 + (target_side[0] - p1)
            angle_target = angle_of_vector(target_side[1] - target_side[0])
            angle_current = angle_of_vector(p2_new - target_side[0])
            poly.rotate(angle_target - angle_current, about_point=target_side[0])
            
            return poly

        # --- Camada 0: Octógono Central ---
        octagon = RegularPolygon(n=8, radius=L / (2*np.sin(PI/8)))
        octagon.set_fill(COLOR_OCT, opacity=1).set_stroke(BLACK, width=2)
        
        layer0_group = VGroup()
        add_polygon_if_unique(octagon, layer0_group)
        self.play(Create(layer0_group))
        self.wait(0.5)

        # --- Camada 1: Primeira Expansão (Octógonos e Quadrados) ---
        layer1_group = VGroup()
        layer1_polys_list = [] # Lista para iterar na próxima camada
        oct_vertices = octagon.get_vertices()

        for i in range(8):
            # Inverte a aresta para construir para fora
            side = (oct_vertices[(i + 1) % 8], oct_vertices[i])
            
            if i % 2 == 0: # Arestas pares recebem octógonos
                new_poly = attach_polygon(8, COLOR_OCT, side)
            else: # Arestas ímpares recebem quadrados
                new_poly = attach_polygon(4, COLOR_SQUARE, side)
            
            if add_polygon_if_unique(new_poly, layer1_group):
                layer1_polys_list.append(new_poly)

        self.play(Create(layer1_group), run_time=3)
        self.wait(0.5)
        
        # --- Camada 2: Segunda Expansão ---
        layer2_group = VGroup()
        for base_poly in layer1_polys_list:
            vertices = base_poly.get_vertices()
            num_sides = len(vertices)

            # Encontra a aresta "interna" (mais próxima do centro da cena)
            min_dist = float('inf')
            attached_edge_index = 0
            for i in range(num_sides):
                mid = (vertices[i] + vertices[(i + 1) % num_sides]) / 2
                dist = np.linalg.norm(mid)
                if dist < min_dist:
                    min_dist = dist
                    attached_edge_index = i
            
            # Expansão a partir de um QUADRADO
            if num_sides == 4:
                # As 3 arestas livres recebem octógonos
                for offset in [1, 2, 3]:
                    edge_index = (attached_edge_index + offset) % num_sides
                    side = (vertices[(edge_index + 1) % num_sides], vertices[edge_index])
                    new_oct = attach_polygon(8, COLOR_OCT, side)
                    add_polygon_if_unique(new_oct, layer2_group)
            
            # Expansão a partir de um OCTÓGONO
            elif num_sides == 8:
                # As 5 arestas livres recebem um padrão alternado de O-S-O-S-O
                for offset in range(2, 7): # As arestas com offset 0, 1 e 7 estão ocupadas
                    edge_index = (attached_edge_index + offset) % num_sides
                    side = (vertices[(edge_index + 1) % num_sides], vertices[edge_index])
                    
                    if offset % 2 == 0: # Posição par no padrão livre: Octógono
                         new_poly = attach_polygon(8, COLOR_OCT, side)
                    else: # Posição ímpar no padrão livre: Quadrado
                         new_poly = attach_polygon(4, COLOR_SQUARE, side)
                    
                    add_polygon_if_unique(new_poly, layer2_group)

        self.play(Create(layer2_group), run_time=4)
        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo3')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/76kPLzGiE5Q"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>

<section class="section5">
  <h2>Ladrilhamento (3,4,6,4)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo4">
    <pre><code>
from manim import *
import numpy as np

class Tiling3464_Corrected(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#333333"
        L = 1.5  # Comprimento do lado dos polígonos

        # --- Cores ---
        COLOR_HEX = GREEN
        COLOR_SQUARE = RED
        COLOR_TRI = ORANGE

        # --- Etapa 1: Criar o Hexágono Central ---
        center_hex = RegularPolygon(n=6, radius=L)
        center_hex.set_fill(COLOR_HEX, opacity=1).set_stroke(BLACK, 2)

        self.play(Create(center_hex))
        self.wait(0.5)

        # --- Etapa 2: Construir a primeira camada de quadrados e triângulos ---
        layer1_squares = VGroup()
        layer1_triangles = VGroup()

        square_verts_list = []
        for i in range(6):
            p1 = center_hex.get_vertices()[i]
            p2 = center_hex.get_vertices()[(i + 1) % 6]

            edge_vector = p2 - p1
            perp_vector = rotate_vector(edge_vector, -PI / 2)

            p3 = p2 + perp_vector
            p4 = p1 + perp_vector
            square_verts_list.append([p1, p2, p3, p4])

        for i in range(6):
            verts_sq = square_verts_list[i]
            square = Polygon(*verts_sq, color=COLOR_SQUARE, fill_opacity=1).set_stroke(BLACK, 2)
            layer1_squares.add(square)

            verts_tri_prev_sq = square_verts_list[i-1]

            v1 = center_hex.get_vertices()[i]
            v2 = verts_tri_prev_sq[2]
            v3 = verts_sq[3]

            triangle = Polygon(v1, v2, v3, color=COLOR_TRI, fill_opacity=1).set_stroke(BLACK, 2)
            layer1_triangles.add(triangle)

        run_time_per_piece = 0.25
        for sq in layer1_squares:
            self.play(Create(sq), run_time=run_time_per_piece)
        for tri in layer1_triangles:
            self.play(Create(tri), run_time=run_time_per_piece)
        self.wait(0.5)

        # --- Etapa 3: Construir a segunda camada externa ---
        layer2_hexagons = VGroup()
        layer2_squares = VGroup()

        for i in range(6):
            verts_sq = square_verts_list[i]
            p1_hex = verts_sq[3] 
            p2_hex = verts_sq[2] 

            side_vector = p2_hex - p1_hex
            hex_points = [p1_hex, p2_hex]
            current_point = p2_hex
            angle = -PI / 3 
            for _ in range(4):
                side_vector = rotate_vector(side_vector, angle)
                current_point = current_point + side_vector
                hex_points.append(current_point)

            new_hex = Polygon(*hex_points, color=COLOR_HEX, fill_opacity=1).set_stroke(BLACK, 2)
            layer2_hexagons.add(new_hex)

        for tri in layer1_triangles:
            verts_tri = tri.get_vertices()
            distances = [np.linalg.norm(v) for v in verts_tri]
            inner_vertex_index = np.argmin(distances)

            p1_sq = verts_tri[(inner_vertex_index + 1) % 3]
            p2_sq = verts_tri[(inner_vertex_index + 2) % 3]

            edge_vector = p2_sq - p1_sq
            perp_vector = rotate_vector(edge_vector, -PI / 2) 
            p3_sq = p2_sq + perp_vector
            p4_sq = p1_sq + perp_vector

            new_square = Polygon(p1_sq, p2_sq, p3_sq, p4_sq, color=COLOR_SQUARE, fill_opacity=1).set_stroke(BLACK, 2)
            layer2_squares.add(new_square)

        for hx in layer2_hexagons:
            self.play(Create(hx), run_time=run_time_per_piece)
        for sq in layer2_squares:
            self.play(Create(sq), run_time=run_time_per_piece)

        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo4')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/tIZmGaYscbw"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>

<section class="section6">
  <h2>Ladrilhamento (3,6,3,6)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo5">
    <pre><code>
from manim import *
import numpy as np

class Tiling3636(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#333333"
        L = 1.5  # Comprimento do lado dos polígonos

        # --- Cores ---
        COLOR_HEX = GREEN
        COLOR_TRI = ORANGE
        
        # --- Sistema para evitar duplicatas ---
        existing_centers = set()
        def add_polygon_if_unique(poly, group_to_add):
            center = poly.get_center()
            rounded_center = (round(center[0], 2), round(center[1], 2))
            if rounded_center not in existing_centers:
                existing_centers.add(rounded_center)
                group_to_add.add(poly)
                return True
            return False

        # --- Etapa 1: Hexágono Central ---
        center_hex = RegularPolygon(n=6, radius=L)
        center_hex.set_fill(COLOR_HEX, opacity=1).set_stroke(BLACK, 2)
        add_polygon_if_unique(center_hex, VGroup())
        
        self.play(Create(center_hex))
        self.wait(0.5)

        # --- Etapa 2: Construir a primeira camada de triângulos ---
        layer1_triangles = VGroup()
        
        for i in range(6):
            p1 = center_hex.get_vertices()[i]
            p2 = center_hex.get_vertices()[(i + 1) % 6]
            
            edge_vector = p2 - p1
            side_length = np.linalg.norm(edge_vector)
            height = side_length * np.sqrt(3) / 2
            mid_point = (p1 + p2) / 2
            perp_vector = rotate_vector(edge_vector, -PI / 2)
            unit_perp_vector = perp_vector / side_length
            p3 = mid_point + unit_perp_vector * height
            
            triangle = Polygon(p1, p2, p3, color=COLOR_TRI, fill_opacity=1).set_stroke(BLACK, 2)
            add_polygon_if_unique(triangle, layer1_triangles)

        run_time_per_piece = 0.2
        for tri in layer1_triangles:
            self.play(Create(tri), run_time=run_time_per_piece)
        self.wait(0.5)

        # --- Etapa 3: Construir a segunda camada de hexágonos ---
        layer2_hexagons = VGroup()
        layer2_hexagons_list = []

        for tri in layer1_triangles:
            verts_tri = tri.get_vertices()
            
            midpoints = [np.linalg.norm((verts_tri[j] + verts_tri[(j + 1) % 3]) / 2) for j in range(3)]
            inner_edge_idx = np.argmin(midpoints)
            
            for offset in [1, 2]:
                edge_idx = (inner_edge_idx + offset) % 3
                p1 = verts_tri[(edge_idx + 1) % 3] 
                p2 = verts_tri[edge_idx]
                
                side_vector = p2 - p1
                hex_points = [p1, p2]
                current_point = p2
                angle = -PI / 3
                for _ in range(4):
                    side_vector = rotate_vector(side_vector, angle)
                    current_point = current_point + side_vector
                    hex_points.append(current_point)
                
                new_hex = Polygon(*hex_points, color=COLOR_HEX, fill_opacity=1).set_stroke(BLACK, 2)
                if add_polygon_if_unique(new_hex, layer2_hexagons):
                    layer2_hexagons_list.append(new_hex)

        for hx in layer2_hexagons:
            self.play(Create(hx), run_time=run_time_per_piece)
        self.wait(0.5)

        # --- Etapa 4: Preenchimento dos vãos com triângulos (MÉTODO À PROVA DE FALHAS) ---
        layer3_triangles = VGroup()
        
        # Itera sobre os triângulos da primeira camada, que servem de "âncora" para os vãos
        for tri_anchor in layer1_triangles:
            verts_anchor = tri_anchor.get_vertices()
            
            # 1. Encontra o vértice externo do triângulo-âncora. Este é o fundo do "V".
            outer_v_anchor = verts_anchor[np.argmax([np.linalg.norm(v) for v in verts_anchor])]

            # 2. Procura na lista de hexágonos quais os 2 que tocam neste vértice
            adjacent_hexagons = []
            for hex_l2 in layer2_hexagons_list:
                for v_hex in hex_l2.get_vertices():
                    if np.linalg.norm(v_hex - outer_v_anchor) < 0.01:
                        adjacent_hexagons.append(hex_l2)
                        break
            
            # Garante que encontramos exatamente 2 hexágonos
            if len(adjacent_hexagons) == 2:
                hex1, hex2 = adjacent_hexagons[0], adjacent_hexagons[1]
                
                # 3. Encontra os outros 2 vértices do triângulo
                
                # Para o hex1, encontra o vértice adjacente ao ponto de encontro que é mais externo
                verts1 = hex1.get_vertices()
                idx1 = np.where([np.allclose(v, outer_v_anchor) for v in verts1])[0][0]
                adj1_a, adj1_b = verts1[(idx1 - 1 + 6) % 6], verts1[(idx1 + 1) % 6]
                outer_v1 = adj1_a if np.linalg.norm(adj1_a) > np.linalg.norm(adj1_b) else adj1_b

                # Para o hex2, faz o mesmo
                verts2 = hex2.get_vertices()
                idx2 = np.where([np.allclose(v, outer_v_anchor) for v in verts2])[0][0]
                adj2_a, adj2_b = verts2[(idx2 - 1 + 6) % 6], verts2[(idx2 + 1) % 6]
                outer_v2 = adj2_a if np.linalg.norm(adj2_a) > np.linalg.norm(adj2_b) else adj2_b

                # 4. Cria o triângulo que preenche o vão
                new_triangle = Polygon(outer_v_anchor, outer_v1, outer_v2, color=COLOR_TRI, fill_opacity=1).set_stroke(BLACK, 2)
                add_polygon_if_unique(new_triangle, layer3_triangles)

        for tri in layer3_triangles:
            self.play(Create(tri), run_time=run_time_per_piece)
        
        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo5')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/zds6ki2IUEc"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>


<section class="section7">
  <h2>Ladrilhamento (4,3,3,4)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo6">
    <pre><code>
from manim import *
import numpy as np

class Tiling33344_GridExpand(Scene):
    def construct(self):
        # --- Configurações ---
        self.camera.background_color = "#333333"
        L = 1.0  # Comprimento do lado dos polígonos

        # --- Cores ---
        COLOR_SQUARE = ORANGE
        COLOR_TRI = PINK
        
        # --- Função Auxiliar ---
        def build_triangle_on_edge(p_start, p_end, color, direction='ccw'):
            side_length = np.linalg.norm(p_end - p_start)
            mid = (p_start + p_end) / 2
            edge = p_end - p_start
            rotation = PI/2 if direction == 'ccw' else -PI/2
            height_vec = rotate_vector(edge, rotation) * np.sqrt(3)/2
            p_new = mid + height_vec
            return Polygon(p_start, p_end, p_new, color=color, fill_opacity=1).set_stroke(BLACK, 2)
        
        all_polys = VGroup()
        
        # --- Parâmetros da Grade (VALORES AUMENTADOS) ---
        num_cols = 21 # Antes era 11
        num_rows = 11 # Antes era 7

        h_tri = L * np.sqrt(3) / 2
        
        # Iterar para construir as linhas de formas
        for j in range(-num_rows // 2, num_rows // 2 + 1):
            y_offset = j * (L + h_tri)
            
            if j % 2 == 0: 
                x_start = -(num_cols * L) / 2 
            else: 
                x_start = -(num_cols * L) / 2 + L/2 

            for i in range(num_cols):
                sq = Square(side_length=L, color=COLOR_SQUARE, fill_opacity=1).set_stroke(BLACK, 2)
                sq.move_to(np.array([x_start + i * L, y_offset, 0]))
                all_polys.add(sq)

            if j < (num_rows // 2):
                for i in range(num_cols - 1):
                    p1_up = np.array([x_start + i * L + L/2, y_offset + L/2, 0])
                    p2_up = np.array([x_start + (i+1) * L + L/2, y_offset + L/2, 0])
                    tri_up = build_triangle_on_edge(p1_up, p2_up, COLOR_TRI, direction='ccw')
                    all_polys.add(tri_up)
                
                for i in range(num_cols - 1):
                    p1_down = np.array([x_start + i * L + L/2, y_offset - L/2, 0])
                    p2_down = np.array([x_start + (i+1) * L + L/2, y_offset - L/2, 0])
                    tri_down = build_triangle_on_edge(p1_down, p2_down, COLOR_TRI, direction='cw')
                    all_polys.add(tri_down)

        # Remove duplicatas
        unique_polys = VGroup()
        centers_added = set()
        for poly in all_polys:
            c = tuple(np.round(poly.get_center(), 3))
            if c not in centers_added:
                unique_polys.add(poly)
                centers_added.add(c)
        all_polys = unique_polys

        # Centraliza e ajusta a escala AUTOMATICAMENTE para caber na tela
        all_polys.center()
        # Define a largura desejada (um pouco menor que a tela para ter margem)
        desired_width = 13 
        current_width = all_polys.get_width()
        if current_width > 0:
            all_polys.scale(desired_width / current_width)

        # --- Animação: Crescer do Centro para Fora ---
        sorted_polys = sorted(all_polys, key=lambda p: np.linalg.norm(p.get_center()))

        self.play(LaggedStart(*[Create(p) for p in sorted_polys], lag_ratio=0.005, run_time=12))
        self.wait(3)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo6')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/OW27Jt4eR10"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>

    <section class="section8">
  <h2>Ladrilhamento (3,6,3,6)</h2>
  <!-- Caixa para o código -->
  <div class="code-box" id="codigo7">
    <pre><code>
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
    </code></pre>
  </div>
  <button onclick="copiarCodigo('codigo7')">Copiar Código</button>
    <script>
    function copiarCodigo(id) {
        const codigo = document.getElementById(id).innerText;
        navigator.clipboard.writeText(codigo).then(() => {
            alert("Código copiado!");
        });
    }
    </script>                      
  <!-- Link do vídeo -->
  <p>Vídeo relacionado:<br>  
          <iframe width="600" height="340"
      src="https://www.youtube.com/embed/tIZmGaYscbw"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
      style="border-radius:8px;">
    </iframe>
  </p>
</section>
</div>
                    
</body>
</html>
